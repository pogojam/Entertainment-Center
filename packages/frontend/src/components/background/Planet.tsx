/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: Comeback (https://sketchfab.com/c3posw01)
license: SKETCHFAB Standard (https://sketchfab.com/licenses)
source: https://sketchfab.com/models/c547788ca8904f528d7da8bc638277d1
title: Planet Earth
*/

import { Float, Html, useFBO, useGLTF, useScroll } from "@react-three/drei";
import { GroupProps, useFrame, useThree } from "@react-three/fiber";
import React, {
  useCallback,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from "react";
import { animated, useSpring, config } from "@react-spring/three";

export default function Planet({ ...props }) {
  const planetRef = useRef<any>();
  const { nodes, materials } = useGLTF("/planet.gltf");

  const scroll = useScroll();

  const { position } = useSpring({
    position: [2, 1, 0],
    config: config.molasses,
  });

  let mouseX = 0;

  const onPointerMove = useCallback((e) => {
    if (e.isPrimary === false) return;
    mouseX = e.clientX - window.innerWidth / 2;
  }, []);

  useFrame(() => {
    const z = scroll.range(0, 1 / 2) * -15;
    const x = scroll.range(0, 1 / 2) * 2;
    position.set([2, x, z]);
  });
  useEffect(() => {
    position.set([-30, -40, -20]);
    const planet = planetRef.current;
    if (planet) {
      planet.scale.set(0.09, 0.09, 0.09);
    }
  }, []);

  useLayoutEffect(() => {
    window.addEventListener("pointermove", onPointerMove);
  }, []);

  return (
    <Float
      rotation={[Math.PI / 3.5, 0, 0]}
      rotationIntensity={4}
      floatIntensity={2}
      speed={1.5}
    >
      <animated.group
        position={position}
        ref={planetRef}
        {...props}
        dispose={null}
      >
        <group rotation={[-Math.PI / 2, 0, 0]}>
          <group rotation={[Math.PI / 2, 0, 0]}>
            <group rotation={[-Math.PI / 2, 0, 0]}>
              <mesh
                geometry={nodes.Earth_Ground_Earth_Ground_0.geometry}
                material={materials.Earth_Ground}
              />
            </group>
            <group rotation={[-Math.PI / 2, 0, 0]}>
              <mesh
                geometry={nodes.Earth_Water_Earth_Water_0.geometry}
                material={materials.Earth_Water}
              />
            </group>
          </group>
        </group>
      </animated.group>
    </Float>
  );
}

// Let's make the marker into a component so that we can abstract some shared logic
function Marker({ children, ...props }) {
  // This holds the local occluded state
  const [occluded, occlude] = useState(false);
  return (
    <Html
      // 3D-transform contents
      transform
      // Hide contents "behind" other meshes
      // occlude
      // Tells us when contents are occluded (or not)
      // onOcclude={occlude}
      // We just interpolate the visible state into css opacity and transforms
      style={{
        transition: "all 0.2s",
        opacity: occluded ? 0 : 1,
        transform: `scale(${occluded ? 0.25 : 1})`,
      }}
      {...props}
    >
      {children}
    </Html>
  );
}

useGLTF.preload("/planet.gltf");
