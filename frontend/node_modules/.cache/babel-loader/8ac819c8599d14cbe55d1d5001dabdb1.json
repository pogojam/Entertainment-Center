{"ast":null,"code":"var util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar bind = require('component-bind');\n\nvar IOStream = require('./iostream');\n\nvar parser = require('./parser');\n\nvar debug = require('debug')('socket.io-stream:socket');\n\nvar emit = EventEmitter.prototype.emit;\nvar on = EventEmitter.prototype.on;\nvar slice = Array.prototype.slice;\nexports = module.exports = Socket;\n/**\n * Base event name for messaging.\n *\n * @api public\n */\n\nexports.event = '$stream';\nexports.events = ['error', 'newListener', 'removeListener'];\nutil.inherits(Socket, EventEmitter);\n/**\n * Bidirectional stream socket which wraps Socket.IO.\n *\n * @param {socket.io#Socket} socket.io\n * @api public\n */\n\nfunction Socket(sio, options) {\n  if (!(this instanceof Socket)) {\n    return new Socket(sio, options);\n  }\n\n  EventEmitter.call(this);\n  options = options || {};\n  this.sio = sio;\n  this.forceBase64 = !!options.forceBase64;\n  this.streams = {};\n  this.encoder = new parser.Encoder();\n  this.decoder = new parser.Decoder();\n  var eventName = exports.event;\n  sio.on(eventName, bind(this, emit));\n  sio.on(eventName + '-read', bind(this, '_onread'));\n  sio.on(eventName + '-write', bind(this, '_onwrite'));\n  sio.on(eventName + '-end', bind(this, '_onend'));\n  sio.on(eventName + '-error', bind(this, '_onerror'));\n  sio.on('error', bind(this, emit, 'error'));\n  sio.on('disconnect', bind(this, '_ondisconnect'));\n  this.encoder.on('stream', bind(this, '_onencode'));\n  this.decoder.on('stream', bind(this, '_ondecode'));\n}\n/**\n * Original emit function.\n *\n * @api private\n */\n\n\nSocket.prototype.$emit = emit;\n/**\n * Emits streams to this corresponding server/client.\n *\n * @return {Socket} self\n * @api public\n */\n\nSocket.prototype.emit = function (type) {\n  if (~exports.events.indexOf(type)) {\n    return emit.apply(this, arguments);\n  }\n\n  this._stream.apply(this, arguments);\n\n  return this;\n};\n\nSocket.prototype.on = function (type, listener) {\n  if (~exports.events.indexOf(type)) {\n    return on.apply(this, arguments);\n  }\n\n  this._onstream(type, listener);\n\n  return this;\n};\n/**\n * Sends a new stream request.\n *\n * @param {String} event type\n * @api private\n */\n\n\nSocket.prototype._stream = function (type) {\n  debug('sending new streams');\n  var self = this;\n  var args = slice.call(arguments, 1);\n  var ack = args[args.length - 1];\n\n  if ('function' == typeof ack) {\n    args[args.length - 1] = function () {\n      var args = slice.call(arguments);\n      args = self.decoder.decode(args);\n      ack.apply(this, args);\n    };\n  }\n\n  args = this.encoder.encode(args);\n  var sio = this.sio;\n  sio.emit.apply(sio, [exports.event, type].concat(args));\n};\n/**\n * Notifies the read event.\n *\n * @api private\n */\n\n\nSocket.prototype._read = function (id, size) {\n  this.sio.emit(exports.event + '-read', id, size);\n};\n/**\n * Requests to write a chunk.\n *\n * @api private\n */\n\n\nSocket.prototype._write = function (id, chunk, encoding, callback) {\n  if (Buffer.isBuffer(chunk)) {\n    if (this.forceBase64) {\n      encoding = 'base64';\n      chunk = chunk.toString(encoding);\n    } else if (!global.Buffer) {\n      // socket.io can't handle Buffer when using browserify.\n      if (chunk.toArrayBuffer) {\n        chunk = chunk.toArrayBuffer();\n      } else {\n        chunk = chunk.buffer;\n      }\n    }\n  }\n\n  this.sio.emit(exports.event + '-write', id, chunk, encoding, callback);\n};\n\nSocket.prototype._end = function (id) {\n  this.sio.emit(exports.event + '-end', id);\n};\n\nSocket.prototype._error = function (id, err) {\n  this.sio.emit(exports.event + '-error', id, err.message || err);\n};\n/**\n * Handles a new stream request.\n *\n * @param {String} event type\n * @param {Function} listener\n *\n * @api private\n */\n\n\nSocket.prototype._onstream = function (type, listener) {\n  if ('function' != typeof listener) {\n    throw TypeError('listener must be a function');\n  }\n\n  function onstream() {\n    debug('new streams');\n    var self = this;\n    var args = slice.call(arguments);\n    var ack = args[args.length - 1];\n\n    if ('function' == typeof ack) {\n      args[args.length - 1] = function () {\n        var args = slice.call(arguments);\n        args = self.encoder.encode(args);\n        ack.apply(this, args);\n      };\n    }\n\n    args = this.decoder.decode(args);\n    listener.apply(this, args);\n  } // for removeListener\n\n\n  onstream.listener = listener;\n  on.call(this, type, onstream);\n};\n\nSocket.prototype._onread = function (id, size) {\n  debug('read: \"%s\"', id);\n  var stream = this.streams[id];\n\n  if (stream) {\n    stream._onread(size);\n  } else {\n    debug('ignore invalid stream id');\n  }\n};\n\nSocket.prototype._onwrite = function (id, chunk, encoding, callback) {\n  debug('write: \"%s\"', id);\n  var stream = this.streams[id];\n\n  if (!stream) {\n    callback('invalid stream id: ' + id);\n    return;\n  }\n\n  if (global.ArrayBuffer && chunk instanceof ArrayBuffer) {\n    // make sure that chunk is a buffer for stream\n    chunk = new Buffer(new Uint8Array(chunk));\n  }\n\n  stream._onwrite(chunk, encoding, callback);\n};\n\nSocket.prototype._onend = function (id) {\n  debug('end: \"%s\"', id);\n  var stream = this.streams[id];\n\n  if (!stream) {\n    debug('ignore non-existent stream id: \"%s\"', id);\n    return;\n  }\n\n  stream._end();\n};\n\nSocket.prototype._onerror = function (id, message) {\n  debug('error: \"%s\", \"%s\"', id, message);\n  var stream = this.streams[id];\n\n  if (!stream) {\n    debug('invalid stream id: \"%s\"', id);\n    return;\n  }\n\n  var err = new Error(message);\n  err.remote = true;\n  stream.emit('error', err);\n};\n\nSocket.prototype._ondisconnect = function () {\n  var stream;\n\n  for (var id in this.streams) {\n    stream = this.streams[id];\n    stream.destroy(); // Close streams when the underlaying\n    // socket.io connection is closed (regardless why)\n\n    stream.emit('close');\n    stream.emit('error', new Error('Connection aborted'));\n  }\n};\n\nSocket.prototype._onencode = function (stream) {\n  if (stream.socket || stream.destroyed) {\n    throw new Error('stream has already been sent.');\n  }\n\n  var id = stream.id;\n\n  if (this.streams[id]) {\n    throw new Error('Encoded stream already exists: ' + id);\n  }\n\n  this.streams[id] = stream;\n  stream.socket = this;\n};\n\nSocket.prototype._ondecode = function (stream) {\n  var id = stream.id;\n\n  if (this.streams[id]) {\n    this._error(id, new Error('Decoded stream already exists: ' + id));\n\n    return;\n  }\n\n  this.streams[id] = stream;\n  stream.socket = this;\n};\n\nSocket.prototype.cleanup = function (id) {\n  delete this.streams[id];\n};","map":null,"metadata":{},"sourceType":"script"}