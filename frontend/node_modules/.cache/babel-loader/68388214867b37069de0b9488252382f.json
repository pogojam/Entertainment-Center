{"ast":null,"code":"var util = require('util');\n\nvar Duplex = require('stream').Duplex;\n\nvar bind = require('component-bind');\n\nvar uuid = require('./uuid');\n\nvar debug = require('debug')('socket.io-stream:iostream');\n\nmodule.exports = IOStream;\nutil.inherits(IOStream, Duplex);\n/**\n * Duplex\n *\n * @param {Object} options\n * @api private\n */\n\nfunction IOStream(options) {\n  if (!(this instanceof IOStream)) {\n    return new IOStream(options);\n  }\n\n  IOStream.super_.call(this, options);\n  this.options = options;\n  this.id = uuid();\n  this.socket = null; // Buffers\n\n  this.pushBuffer = [];\n  this.writeBuffer = []; // Op states\n\n  this._readable = false;\n  this._writable = false;\n  this.destroyed = false; // default to *not* allowing half open sockets\n\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\n  this.on('finish', this._onfinish);\n  this.on('end', this._onend);\n  this.on('error', this._onerror);\n}\n/**\n * Ensures that no more I/O activity happens on this stream.\n * Not necessary in the usual case.\n *\n * @api public\n */\n\n\nIOStream.prototype.destroy = function () {\n  debug('destroy');\n\n  if (this.destroyed) {\n    debug('already destroyed');\n    return;\n  }\n\n  this.readable = this.writable = false;\n\n  if (this.socket) {\n    debug('clean up');\n    this.socket.cleanup(this.id);\n    this.socket = null;\n  }\n\n  this.destroyed = true;\n};\n/**\n * Local read\n *\n * @api private\n */\n\n\nIOStream.prototype._read = function (size) {\n  var push; // We can not read from the socket if it's destroyed obviously ...\n\n  if (this.destroyed) return;\n\n  if (this.pushBuffer.length) {\n    // flush buffer and end if it exists.\n    while (push = this.pushBuffer.shift()) {\n      if (!push()) break;\n    }\n\n    return;\n  }\n\n  this._readable = true; // Go get data from remote stream\n  // Calls\n  // ._onread remotely\n  // then\n  // ._onwrite locally\n\n  this.socket._read(this.id, size);\n};\n/**\n * Read from remote stream\n *\n * @api private\n */\n\n\nIOStream.prototype._onread = function (size) {\n  var write = this.writeBuffer.shift();\n  if (write) return write();\n  this._writable = true;\n};\n/**\n * Write local data to remote stream\n * Calls\n * remtote ._onwrite\n *\n * @api private\n */\n\n\nIOStream.prototype._write = function (chunk, encoding, callback) {\n  var self = this;\n\n  function write() {\n    // We can not write to the socket if it's destroyed obviously ...\n    if (self.destroyed) return;\n    self._writable = false;\n\n    self.socket._write(self.id, chunk, encoding, callback);\n  }\n\n  if (this._writable) {\n    write();\n  } else {\n    this.writeBuffer.push(write);\n  }\n};\n/**\n * Write the data fetched remotely\n * so that we can now read locally\n *\n * @api private\n */\n\n\nIOStream.prototype._onwrite = function (chunk, encoding, callback) {\n  var self = this;\n\n  function push() {\n    self._readable = false;\n    var ret = self.push(chunk || '', encoding);\n    callback();\n    return ret;\n  }\n\n  if (this._readable) {\n    push();\n  } else {\n    this.pushBuffer.push(push);\n  }\n};\n/**\n * When ending send 'end' event to remote stream\n *\n * @api private\n */\n\n\nIOStream.prototype._end = function () {\n  if (this.pushBuffer.length) {\n    // end after flushing buffer.\n    this.pushBuffer.push(bind(this, '_done'));\n  } else {\n    this._done();\n  }\n};\n/**\n * Remote stream just ended\n *\n * @api private\n */\n\n\nIOStream.prototype._done = function () {\n  this._readable = false; // signal the end of the data.\n\n  return this.push(null);\n};\n/**\n * the user has called .end(), and all the bytes have been\n * sent out to the other side.\n * If allowHalfOpen is false, or if the readable side has\n * ended already, then destroy.\n * If allowHalfOpen is true, then we need to set writable false,\n * so that only the writable side will be cleaned up.\n *\n * @api private\n */\n\n\nIOStream.prototype._onfinish = function () {\n  debug('_onfinish'); // Local socket just finished\n  // send 'end' event to remote\n\n  if (this.socket) {\n    this.socket._end(this.id);\n  }\n\n  this.writable = false;\n  this._writableState.ended = true;\n\n  if (!this.readable || this._readableState.ended) {\n    debug('_onfinish: ended, destroy %s', this._readableState);\n    return this.destroy();\n  }\n\n  debug('_onfinish: not ended');\n\n  if (!this.allowHalfOpen) {\n    this.push(null); // just in case we're waiting for an EOF.\n\n    if (this.readable && !this._readableState.endEmitted) {\n      this.read(0);\n    }\n  }\n};\n/**\n * the EOF has been received, and no more bytes are coming.\n * if the writable side has ended already, then clean everything\n * up.\n *\n * @api private\n */\n\n\nIOStream.prototype._onend = function () {\n  debug('_onend');\n  this.readable = false;\n  this._readableState.ended = true;\n\n  if (!this.writable || this._writableState.finished) {\n    debug('_onend: %s', this._writableState);\n    return this.destroy();\n  }\n\n  debug('_onend: not finished');\n\n  if (!this.allowHalfOpen) {\n    this.end();\n  }\n};\n/**\n * When error in local stream\n * notyify remote\n * if err.remote = true\n * then error happened on remote stream\n *\n * @api private\n */\n\n\nIOStream.prototype._onerror = function (err) {\n  // check if the error came from remote stream.\n  if (!err.remote && this.socket) {\n    // notify the error to the corresponding remote stream.\n    this.socket._error(this.id, err);\n  }\n\n  this.destroy();\n};","map":null,"metadata":{},"sourceType":"script"}